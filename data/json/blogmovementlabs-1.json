[
  {
    "title": "Community vs Insiders: Can They Both Win?",
    "url": "https://blog.movementlabs.xyz/article/community-vs-insiders-can-they-both-win",
    "html": "Community vs Insiders: Can They Both Win?\nMay 26, 2024\nRushi Manche\n\nOver the past few weeks, CT has been discussing the high fully diluted value (FDV) and low float of many projects. There’s a growing concern that insiders, such as investors, team members, and influencers are reaping the early benefits while the community – the very people who invest their time, energy, and love into the protocol – have little to no say in its direction.\n\nI’ve spent the last three weeks speaking with community members, investors, influencers, etc to find a solution to this issue. To better understand the problem, let’s first examine the interests of each stakeholder:\n\nInvestors: These early backers provide capital and reputational support to protocols for years. They are often motivated to minimize sell pressure in the first few months after launch to ensure a healthy price chart.\n\nTeam: Like investors, the team also wants to see healthy and sustainable price action. However, the team also needs to balance the needs and interests of various parties in order to gain mindshare, exposure, and business development opportunities, especially before launch.\n\nContent Curators: These individuals aim to minimize their risk while maximizing their upside. They prefer to create organic content rather than being forced to post on an unnatural schedule.\n\nCommunity: (The most crucial stakeholder) Comprised of the people for whom the teams build their products. They want to be involved in the upside as early as possible and contribute to the pre-token generation event (TGE) phase of the project.\n\nPrevious attempts to address this dilemma have included short vesting schedules, lower valuations, and airdrop strategies. However, these solutions often lead to conflicts of interest, price instability, and regulatory concerns.\n\nBUT… what if there was a way to maintain consistent tokenomics across all shareholders, minimize downside risk for content creators, and involve the community in the decision-making process? I believe I have an idea that could work.\n\nINTRODUCING “The Forum”:\n\nA limited number of content curators (or KOLs, even though I hate the word) are given allocation at a defined valuation with the same vesting terms as private investors.\n\nTop community members (based on Discord activity, engagement, and project development) are also given the same opportunity to invest as curators.\n\nBoth parties have the opportunity to receive their premium as a marketing grant for contributing to the network (ecosystem grants, tutorial videos, event organizing, etc.).\n\nBoth curators and community members must undergo accredited investor review via KYC to maintain compliance.\n\nCommunity members (especially those who do not want to go through KYC) will eventually be part of the “Senate” – a governance body that can vote on which curators they want to see rewarded and vote out unproductive curators. They earn points for their active contribution to the network, which can be redeemed for rewards at launch. This way, the community has two avenues to be involved which is advantageous especially for those without liquidity to deploy in early stage protocols. The Senate is compromised of 100 of the most active members in a given discord – votes are manually tracked within Discord or using Jokerace where each representative submits a contest and a whitelisted group (The Senate) is able to vote. Post launch, governance proposals can coordinate election.\n\nThis structure enables community members to get involved in earlier financing rounds while still mitigating risk and ensuring compliance for the protocol. Teams and investors also benefit, as they can get their protocol in the hands of more power users and influencers who can bring mindshare to their network.\n\nI’ve conducted some initial beta testing, and the feedback has been encouraging – curators get a fair deal, teams and investors avoid excessive sell pressure and maintain compliance, and the community is directly involved from the early stages.\n\nIn the spirit of transparency, I welcome any constructive criticism and honest feedback. Many founders, including myself, are searching for ways to keep the community engaged while growing their protocols, and it would be cool to develop a system designed by and for community participants. Note: this is purely field testing for feedback from the community out of personal interest for the future of protocol launches.\n\nNEXT STEPS:\n\nPlease share your comments, ideas, and concerns in the comments below.\n\nI’ll host a community Town Hall on Movement Spaces with leading founders, investors, and community members post-Consensus to open the floor for discussion. A Google Form will be released soon to collect questions in advance.\n\nShort Disclaimer: This article covers content for general informational purposes only, no responsibility or liability is accepted for any errors of fact or omission expressed herein. It represents the personal views of the author(s) and it does not represent the views of Movement Labs.\n\n© 2024 Movement Labs."
  },
  {
    "title": "Tutorial: Building an EigenLayer AVS that integrates with Movement network",
    "url": "https://blog.movementlabs.xyz/article/tutorial-eigenlayer-avs-movement-network",
    "html": "Tutorial: Building an EigenLayer AVS that integrates with Movement network\nTutorials\nJune 6, 2024\n\nIn this guide, you’ll build an Actively Validated Service (AVS) that interacts with both EigenLayer’s validator system and Movement network.\n\nHere’s the modified repository.\n\nIf you inspect operator.go you’ll see how we modified EigenLayer’s Incredible Squaring AVS to build an AVS that queries Movement network to generate a random number.\n\nWe’ll do this in three parts:\n\nIntro: Understanding AVSs and getting set up\n\nImplementing a simple AVS (Infinite Squaring, created by EigenLayer team)\n\nModifying an AVS to interact with Movement network\n\nPart 1: Understanding AVSs\n\nLet’s dive in. First of all:\n\nWhat’s an AVS?\n\nFrom the EigenLayer docs:\n\nAn AVS is any system that requires its own distributed validation semantics for verification, such as sidechains, data availability layers, new virtual machines, keeper networks, oracle networks, bridges, threshold cryptography schemes, trusted execution environments and more.\n\nhttps://docs.eigenlayer.xyz/eigenlayer/avs-guides/avs-developer-guide\n\nIt might seem complicated at first, but by the end of this guide, you’ll know how to build and customize your own AVS!\n\nA fundamental thing to understand is that an AVS requires an off-chain layer for executing some operations. That’s why the parties who sign off on an AVS’ off-chain work are called “operators.”\n\nIf you look at the diagram from EigenLayer’s docs, you’ll see some key components of an AVS:\n\n“Each AVS has its own set of contracts that hold state relevant to the service’s functionality, such as what operators are running the service and how much stake is securing the service.” – EigenLayer docs\n\nThe EigenLayer contracts that an AVS uses are:\n\nStrategyManager: where stakers deposit assets to stake\n\nDelegationManager: lets stakers choose which operators to delegate to. AVS operators register and deregister via DelegationManager\n\nAVSDirectory: directory of all registered AVSs\n\nServiceManager: is the entry point for each AVS. It must implement the interface expected by the EigenLayer protocol.\n\nThey do an awesome job explaining everything in full detail, so please feel free to take a deep dive into EigenLayer’s resources as needed, and come back when you’re ready to build.\n\nHow does the Incredible Squaring AVS work?\n\nWe’ll follow EigenLayer’s guide to build our own simple AVS before creating a custom version.\n\nTheir example AVS simply squares a number. But it’s still incredible, in that operators (who have staked digital assets via EigenLayer contracts) sign to attest the execution of the squaring operation, and then a record of the execution is stored on-chain.\n\nHere’s how it works:\n\nPrerequisites:\n\nOperators register with the EigenLayer DelegationManager contract.\n\nIncredible Squaring AVS is deployed and registered to an implementation of the AVSDirectory contract.\n\nOperators register with the AVS through its RegistryCoordinator.\n\nThe Task Generator entity sends the number to be squared to the AVS contract (IncredibleSquaringTaskManager.sol).\n\nAVS contract emits a NewTaskCreated event to represent the new number to be squared.\n\nOperators listen to the AVS contract for the event, square the number, sign the result with a BLS signature, and send their signature to the Aggregator entity.\n\nThe Aggregator combines each into a single aggregated signature using BLS signature aggregation. Once the quorum threshold is met the Aggregator sends the aggregated signature back to the AVS contract.\n\nAVS contract verifies that the quorum thresholds were met and that the aggregated signature is valid. If so, the squared number is accepted.\n\nFor the Incredible Squaring AVS, each request to square a number goes through this lifecycle flow:\n\nNote: some aspects of the above lifecycle flow, such as the BLS signature type, are not required for all AVSs.\n\nPart 2: Set up your local environment and run the Incredible Squaring AVS demo\n\nYou can follow the setup steps in the Incredible Squaring GitHub repo. The main steps are:\n\nInstall foundry and zap-pretty\n\nInstall Docker and build the AVS contracts\n\nStart an anvil chain locally\n\nStart the aggregator\n\nRegister the operator with eigenlayer and incredible-squaring, and then start the process\n\nBelow is the make terminal for the aggregator, which sends tasks to operators and aggregates task responses:\n\nThe three terminals running are:\n\nThe anvil chain ( make start-anvil-chain-with-el-and-avs-deployed )\n\nThe aggregator ( make start-aggregator )\n\nThe operator ( make start-operator )\n\nFollow the steps in the repo and you’ll be up and running.\n\nThe repo also features a great diagram showing the Incredible Squaring AVS architecture:\n\nSource: https://github.com/Layr-Labs/incredible-squaring-avs\n\nIn that repository, EigenLayer breaks down the architecture in even more detail.\n\nHere’s a video by Samuel Laferriere showing how to run the Infinite Squaring AVS locally.\n\nNext, we’ll modify this AVS to query the Movement network instead of squaring a number.\n\nPart 3: Modifying an AVS to interact with Movement network\n\nNow, the fun part.\n\nInstead of squaring a number, we’ll query the Movement network for the last digit of a block hash.\n\nThis could be useful as a random number generator.\n\nYour own AVS for generating randomness\n\nSuppose you have a game where Gorillas are racing. And you want to have some randomness for how fast each Gorilla goes during a given race. The winner gets a barrel of bananas.\n\nAll the contestants line up, commit to the race, and then a random number is generated from the last digit of a block hash for a block determined by the TaskGenerator entity based on the current timestamp. Contestants with higher randomly generated numbers run faster and win the race.\n\nEssential aspects of the design:\n\nThe block is chosen after the contestants all commit to the race.\n\nTaskGenerator must act as an automaton selecting the block without influencing which block is selected.\n\nNext we’ll look at the parts of the AVS contracts that deal specifically with the task. And we’ll make some small but important changes.\n\nInspect the AVS code to see what you’ll need to modify\n\nIf you look at IncredibleSquaringTaskManager.sol you’ll see the squaring math as part of the challenge process:\n\n// logic for checking whether challenge is valid or not\nuint256 actualSquaredOutput = numberToBeSquared * numberToBeSquared;\nbool isResponseCorrect = (actualSquaredOutput ==\n    taskResponse.numberSquared);\n\n// if response was correct, no slashing happens so we return\nif (isResponseCorrect == true) {\n    emit TaskChallengedUnsuccessfully(referenceTaskIndex, msg.sender);\n    return;\n}\nCopy\n\nInstead of checking whether a number was squared, we want to check whether the block hash of a specific Movement network block ended with the same number as in taskResponse.\n\noperator.go has some number squaring in the ProcessNewTaskCreatedLog function:\n\n// Takes a NewTaskCreatedLog struct as input and returns a TaskResponseHeader struct.\n// The TaskResponseHeader struct is the struct that is signed and sent to the contract as a task response.\nfunc (o *Operator) ProcessNewTaskCreatedLog(newTaskCreatedLog *cstaskmanager.ContractIncredibleSquaringTaskManagerNewTaskCreated) *cstaskmanager.IIncredibleSquaringTaskManagerTaskResponse {\n\to.logger.Debug(\"Received new task\", \"task\", newTaskCreatedLog)\n\to.logger.Info(\"Received new task\",\n\t\t\"numberToBeSquared\", newTaskCreatedLog.Task.NumberToBeSquared,\n\t\t\"taskIndex\", newTaskCreatedLog.TaskIndex,\n\t\t\"taskCreatedBlock\", newTaskCreatedLog.Task.TaskCreatedBlock,\n\t\t\"quorumNumbers\", newTaskCreatedLog.Task.QuorumNumbers,\n\t\t\"QuorumThresholdPercentage\", newTaskCreatedLog.Task.QuorumThresholdPercentage,\n\t)\n\tnumberSquared := big.NewInt(0).Exp(newTaskCreatedLog.Task.NumberToBeSquared, big.NewInt(2), nil)\n\ttaskResponse := &cstaskmanager.IIncredibleSquaringTaskManagerTaskResponse{\n\t\tReferenceTaskIndex: newTaskCreatedLog.TaskIndex,\n\t\tNumberSquared:      numberSquared,\n\t}\n\treturn taskResponse\n}\nCopy\n\nI’m not sure how I feel about this IIncredibleSquaringTaskManagerTaskResponse with two “I”s. We should probably dig deeper into the architecture of this AVS. However, if all we need to do is change the functionality of the above Solidity and Go code, then that would be very convenient.\n\nThe Go code to square the number is:\n\nnumberSquared := big.NewInt(0).Exp(newTaskCreatedLog.Task.NumberToBeSquared, big.NewInt(2), nil)\n\nEvery 10 seconds, the aggregator sends a new task out to operators and increments taskNum:\n\nfunc (agg *Aggregator) Start(ctx context.Context) error {\n\tagg.logger.Infof(\"Starting aggregator.\")\n\tagg.logger.Infof(\"Starting aggregator rpc server.\")\n\tgo agg.startServer(ctx)\n\n\t// TODO(soubhik): refactor task generation/sending into a separate function that we can run as goroutine\n\tticker := time.NewTicker(10 * time.Second)\n\tagg.logger.Infof(\"Aggregator set to send new task every 10 seconds...\")\n\tdefer ticker.Stop()\n\ttaskNum := int64(0)\n\t// ticker doesn't tick immediately, so we send the first task here\n\t// see https://github.com/golang/go/issues/17601\n\t_ = agg.sendNewTask(big.NewInt(taskNum))\n\ttaskNum++\n\t...\nCopy\n\nTo get a deeper understanding, study the sendNewTask function.\n\nFor now, let’s modify the code to do something more interesting than squaring a number.\n\nCustomize your AVS to query the Movement network\n\nBecause the aggregator starts off with taskNum equal to 0, then increments by 1, one simple way to generate a “random” number is to iterate through blocks with height 0, 1, 2, etc, and take the last digit of the block hash.\n\nYou can use the Aptos REST API spec to query the Movement network M1 RPC endpoint (https://aptos.devnet.m1.movementlabs.xyz/). See Movement docs for a list of all endpoints.\n\nSo in operator.go, instead of numberSquared := big.NewInt(0).Exp(newTaskCreatedLog.Task.NumberToBeSquared, big.NewInt(2), nil)\n\nwe’ll do something like randomNumber := // code to get the last digit of the number\n\nand modify taskResponse to include randomNumber. I’m not going to change the name of NumberToBeSquared because it seems like it could open up a can of worms that would require deeper changes to the code. We’re doing a “quick and dirty” modification here. For a production dApp you’d want to go through all of the code and make sure everything is named properly and makes sense as a cohesive unit. In this case, we just want to get a random number back.\n\nWhy could this work for generating randomness in a game? If all players line up for a race, and the random number determines, say, which player is the fastest, there’s no way for players to know in advance which block will be selected.\n\nCould players somehow find a way to cheat? Probably, in particular, if they could coordinate with the TaskGenerator.\n\nHowever, the block height selected as the input will be publicly visible, so it will be easy to verify that the last digit of the hash is correct.\n\nTo find any security flaws, you’ll want to get an audit of your implementation if you build a real game or dApp.\n\nImplementing our AVS modification’s code\n\nThe Movement M1 endpoint for getting blocks by height is:\n\nhttps://aptos.devnet.m1.movementlabs.xyz/blocks/by_height/{block_height}\n\ntaskResponse‘s value is of the type &cstaskmanager.IIncredibleSquaringTaskManagerTaskResponse which is defined in a binding.go file. Modify the struct to include an integer LastDigitOfBlockHash:\n\n// IIncredibleSquaringTaskManagerTaskResponse is an auto generated low-level Go binding around an user-defined struct.\ntype IIncredibleSquaringTaskManagerTaskResponse struct {\n\tReferenceTaskIndex uint32\n\tNumberSquared      *big.Int\n\tLastDigitOfBlockHash int\n}\nCopy\n\nBack in operator.go, you’ll need more imports for our RPC calls and handling the response data:\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"io/ioutil\"\n    \"net/http\"\n    \"strconv\"\n    \"log\"\n\n    // Assuming the rest of your imports stay the same\n)\nCopy\n\nFinally define a Block struct to help handle block data, and modify the ProcessNewTaskCreatedLog function so it queries Movement network for a block hash and takes the last digit:\n\n// Block struct to unmarshal the JSON response from the Movement API\ntype Block struct {\n    BlockHeight     string `json:\"block_height\"`\n    BlockHash       string `json:\"block_hash\"`\n    BlockTimestamp  string `json:\"block_timestamp\"`\n    FirstVersion    string `json:\"first_version\"`\n    LastVersion     string `json:\"last_version\"`\n}\n\n// Takes a NewTaskCreatedLog struct as input and returns a TaskResponseHeader struct.\n// The TaskResponseHeader struct is the struct that is signed and sent to the contract as a task response.\nfunc (o *Operator) ProcessNewTaskCreatedLog(newTaskCreatedLog *cstaskmanager.ContractIncredibleSquaringTaskManagerNewTaskCreated) *cstaskmanager.IIncredibleSquaringTaskManagerTaskResponse {\n    o.logger.Debug(\"Received new task\", \"task\", newTaskCreatedLog)\n    o.logger.Info(\"Received new task\",\n        \"numberToBeSquared\", newTaskCreatedLog.Task.NumberToBeSquared,\n        \"taskIndex\", newTaskCreatedLog.TaskIndex,\n        \"taskCreatedBlock\", newTaskCreatedLog.Task.TaskCreatedBlock,\n        \"quorumNumbers\", newTaskCreatedLog.Task.QuorumNumbers,\n        \"QuorumThresholdPercentage\", newTaskCreatedLog.Task.QuorumThresholdPercentage,\n    )\n    \n    // Convert NumberToBeSquared to int and use it as the block height\n    blockHeight := newTaskCreatedLog.Task.NumberToBeSquared.Int64()\n    \n    // Fetch the last digit of the block hash for the given block height\n    lastDigitOfBlockHash := getLastDigitOfMovementBlockHash(int(blockHeight))\n    \n    // Compute the square of the number to be squared\n    numberSquared := big.NewInt(0).Exp(newTaskCreatedLog.Task.NumberToBeSquared, big.NewInt(2), nil)\n    \n    // Update the task response to include the last digit of the block hash\n    taskResponse := &cstaskmanager.IIncredibleSquaringTaskManagerTaskResponse{\n        ReferenceTaskIndex: newTaskCreatedLog.TaskIndex,\n        NumberSquared:      numberSquared,\n        LastDigitOfBlockHash: lastDigitOfBlockHash, // Include the last digit of the block hash\n    }\n    \n    return taskResponse\n}\n\n// getLastDigitOfMovementBlockHash fetches the last digit of the block hash for a given block height using the Movement API\nfunc getLastDigitOfMovementBlockHash(blockHeight int) int {\n    // Make an HTTP GET request to the Aptos API to fetch the block hash by height\n    resp, err := http.Get(fmt.Sprintf(\"https://aptos.devnet.m1.movementlabs.xyz/blocks/by_height/%d\", blockHeight))\n    if err!= nil {\n        log.Fatalf(\"Error fetching block: %v\", err)\n    }\n    defer resp.Body.Close()\n\n    body, err := ioutil.ReadAll(resp.Body)\n    if err!= nil {\n        log.Fatalf(\"Error reading response body: %v\", err)\n    }\n\n    var block Block\n    json.Unmarshal(body, &block)\n\n\t// Extract the last hex digit of the block hash (will be values from 0 to 15)\n\tlastDigit, err := strconv.ParseInt(string([]byte(block.BlockHash)[len(block.BlockHash)-1]), 16, 8)\n\tif err!= nil {\n\t\tlog.Fatalf(\"Error parsing last digit of block hash: %v\", err)\n\t}\n\treturn int(lastDigit)\n}\nCopy\n\nIf you restart your anvil chain, aggregator, and operator, you should now begin seeing the aggregator log last digits of block hashes:\n\nI’m not sure why each response is logged twice. Ah, the mysteries of AVS.\n\nAll done! Right? What other steps would we need to take, for our “random” number generator to be a proper AVS?\n\nWell, there is the issue of the challenged contract. But you only need to allow challenges if you’ll have slashing. So I’ll leave that consideration to you.\n\nIn a real dApp, you’d want the task generator to do something like take the last digit of a timestamp when generating a task, instead of going in a predictable order like 0, 1, 2, etc.\n\nYou might want to build a more interesting example, like for example something involving deploying EigenLayer contracts on MEVM with Fractal.\n\nThe sky’s the limit! I can’t wait to see what you build.\n\nJoin the Movement developer community on Discord and never miss the next Move.\n\n© 2024 Movement Labs."
  },
  {
    "title": "Movement’s Battle of Olympus Calls for Heroes!",
    "url": "https://blog.movementlabs.xyz/article/movements-battle-of-olympus-calls-for-heroes",
    "html": "Movement’s Battle of Olympus Calls for Heroes!\nAnnouncements\nJune 13, 2024\n\nSTARTING TODAY, JUNE 13, Movement Labs summons all digital warriors and blockchain buffs to a grand campaign: The Battle of Olympus Hackathon. If you’re a Web3 developer or non-dev enthusiast, this is a call to arms, a chance to show the world what you can do. Should you join us on this mission, you’ll fight to further the Movement. You, your team, and other heroes will battle by building.\n\nWhat will you build? Anything you can dream.\n\nMovement is an integrated, modular platform with leading speed, security, and interoperability, equipping you to go big. The territory is wide open. Names are yet to be made. By taking up arms, you can forge your legend and help shape the destiny of the Movement ecosystem.\n\nWhat could you win for participating from July 17-September 17?\n\nHonor and reputation\n\nEarly access to Movement apps\n\nRewards and digital treasure\n\nAn app of your own (built by your own hands!)\n\nCurious for more? Here’s a quick overview of the battleplan.\n\nSteps: Joining the Battle of Olympus as a Developer\n\nDo you want to compete as a developer, joining the new Masons’ guild and fighting alongside the bravest, most talented engineers in all the Web3 kingdom? Here’s how to enter, build, and win rewards.\n\n1. Enter: Register your team on the Battle of Olympus website.\n\n2. Engage: Join our dev community on Discord to connect and stay updated.\n\n3. Build: Develop your project on the Movement Labs testnet\n\n4. Submit: Send us your project by the deadline.\n\n5. Present: Present to our judges.\n\nNot a Dev? Compete by Joining 1 of 4 Guilds\n\nIf you aren’t an engineer, you can still take up virtual arms and help expand the Movement. Four other guilds (beyond the dev-focused Mason’s guild) put you on the front lines.\n\nAnd yes, you can still earn rewards.\n\nPathfinders: Design onboarding guides, engage the community, and organize events\n\nCreators: Create Movement-related content, memes, and contribute to worldbuilding\n\nExplorers: Engage with partners, write articles, and analyze ecosystem data\n\nScholars: Write content, design quizzes, and collaborate on reports about the hackathon and Movement ecosystem\n\nBattle Rankings (and Categories)\n\nEach developer team will be ranked on a master leaderboard. Progress will determine how combatants rank up or down. Developers will build in the categories of DeFi, Gaming and Entertainment, Social and Community Tools, Infrastructure and Dev Tools, or NFTs.\n\nThese categories are the pillars of a robust blockchain ecosystem. Movement is designed to become a leader in each, and battlers help the Movement ecosystem catapult forward to meet its potential.\n\nNo matter your focus, you can earn glory in The Battle of Olympus.\n\nDeveloper Docs and Resources\n\nWant to learn more about building on Movement? See these resources:\n\nMovement Documentation\n\nMovement Learning Resources\n\nBuilding with Movement\n\nTimeline\n\nRegistration Opens: June 13\n\nBattle Begins: July 17\n\nBattle Ends: September 17\n\nWinners Named: September 17-18 (at Movement’s Integrated Day at Token 2049 in Singapore)\n\nAfter the Battle: the March to Mainnet\n\nThe Battle of Olympus will be held on Movement’s testnet.\n\nA noble goal for ambitious participants: build on testnet, dominate the Battle of Olympus, earn rewards, and then deploy on Movement mainnet at launch. Get rewards and a headstart in a blockchain ecosystem with boundless potential.\n\nThe path to glory awaits you!\n\nJoin the Battle of Olympus today.\n\nAbout Movement:\n\nMovement is a network of Move-based blockchains, designed to combine smart contract security and parallelization with the liquidity and user base of the EVM. M2, the first MEVM (Move + EVM) ZK L2 on Ethereum, powered by Celestia, seamlessly integrates MoveVM with Ethereum, setting a new standard for blockchain interoperability and performance.\n\nJoin the Movement\n\nDevelopers, researchers, and blockchain enthusiasts are invited to join Movement Labs on this transformative journey. Engage with the testnet, explore research papers and blog posts, build with the Movement SDK, and immerse in the Move programming language.\n\nFor more information about Movement Labs and to explore the documentation, visit movementlabs.xyz\n\n© 2024 Movement Labs."
  },
  {
    "title": "Movement Labs Research Explains: What Is Movement?",
    "url": "https://blog.movementlabs.xyz/article/what-is-movement-move-blockchain",
    "html": "Movement Labs Research Explains: What Is Movement?\nResearch, Tech Deep Dives\nJuly 29, 2024\nFranck Cassez, Shashank Motepalli & Andreas Penzkofer\n\nIn this post, we introduce the Movement Network, a network of high-throughput, fast-finality Move-based rollups secured by Ethereum. First, we explain why we chose Move and the Move Virtual Machine (MoveVM) for the execution layer (high throughput). Next, we introduce the main features of our modular, configurable stack unlocking interoperable Move Rollups. We explore two features in detail: interoperability via atomic cross-chain transactions, and fast finality provided by a fast-finality rollup mechanism.\n\n(For further reading, see the Movement whitepaper.)\n\nThe Move Language Advantage\n\nSmart contracts implement the business logics of distributed Applications (dApps). They provide an interface for end-users to use applications through transactions. Contracts are programs, and any vulnerability (bug, erroneous logic) in their code can be exploited by malicious attackers.\n\nFirst generation Web3 programming languages like Solidity and the Ethereum Virtual Machine (EVM) are not built for security. Re-entrancy (Solidity/EVM bytecode) is a feature that is regularly exploited by attackers. Some common patterns like the upgradability of contracts (Solidity/OpenZeppelin) have serious drawbacks. In 2023, according to Certik, code vulnerabilities cost $291M+; in 2024, according to DefiLlama, hacks have already cost $970M+.\n\nAs Trail of Bits CEO Dan Guido[1] mentioned in the podcast series Building Better Systems, What the hell are the blockchain people doing, and why isn't it a dumpster fire? \"Solidity seems to have re-invented all of the vulnerabilities that were wiped out of languages like Rust or Go,\" he said. \"The Solidity language needs to go.\"\n\nIn 2024, Solidity remains, but fortunately a solid and principled alternative has emerged: the Move language.\n\nMove proposes a new approach to Web3 development. Move introduces a novel programming paradigm known as resource-oriented programming, providing the primitives developers need to develop secure contracts. The Move language is supported by the Move Prover [2], offering formal verification, the gold standard for developing secure critical systems. Further, the Move MoveVM implements BlockSTM a state-of-the-art parallel execution engine, delivering 160K+ TPS.\n\nAt Movement Labs, we want to build of network where the most advanced Web3 technology, incarnated by Move, meets the most crypto-economically secure chain, Ethereum.\n\nThe Movement Network\n\nApplication specific chains are becoming the norm. This is driven by the fact that applications in DeFi, gaming, or supply chain have different requirements for latency and throughput. Privacy or proprietary requirements may also need to isolate a chain and its dApps from others.\n\nThe Movement Network is a set of modular and configurable Move Rollups that provide a platform for deploying interoperable, application-specific chains. Each Movement Rollup can use a custom Data Availability layer (default is Celestia), custom sequencing (default is Movement's decentralized shared sequencer, M1), a custom finality mechanism (default is our fast staked attestations), and they all share the MoveVM for powerful execution.\n\nBy sharing a common modular architecture, the chains in Movement Network can interoperate, share the same bridge and DA layer, and use our fast-finality rollups settlement mechanism.\n\nOur execution engine supports both Move and EVM transactions. This feature is critical, allowing Web3 developers to onboard to the Movement network quickly. It also empowers developers to leverage existing EVM dApps and extend them, benefiting from the advanced features of the Move platform. For instance, standard EVM contracts like ERC-20 can be deployed on Movement Network, while new and secure Move dApps can interoperate with them.\n\nInteroperability with Atomic Cross-Chain Transactions\n\nThe default configuration of a Move Rollup uses our decentralized shared sequencer, M1. M1 supports customizable transactions ordering, with templates from a set of approaches, such as fair transaction ordering for mitigation of front-running attacks and censorship resistance. The M1 sequencer module offers a solution where fees can be collected by the rollup rather than by an external service (marketplace), thus increasing utility of native tokens in the Movement Network.\n\nShared sequencing is the ability of the sequencer module to sequence transactions on multiple chains. This is instrumental for interoperability between different rollups, such as via cross-chain atomic transactions.\n\nAn atomic cross-chain transaction involves more than one chain and has one component per chain involved. The requirement is that all the components of the cross-chain transaction are executed successfully or none of them are executed. For instance, assume Alice and Bob will swap 1 ETH on chains A and B. This can be implemented with an atomic transaction of two components: 1) where Alice transfers 1 ETH to Bob on chain A, and 2) where Bob transfers 1 ETH to Alice on chain B. Cross-chain atomic transactions are frequently used in DeFi applications, such as for cross-chain arbitrage. For many use cases it is simpler and more secure than bridging between chains.\n\nSynchronous Cross-chain atomic transactions are a novel concept with interesting challenges. For instance, how do involved chains communicate efficiently about their progress? How do chains with different finality assumptions (confirmation of a transaction) interoperate? What happens if we need to rollback a cross-chain transaction?\n\nImplementing a secure atomic cross-chain transaction mechanism is an active area of research. Movement Labs' research team is developing an innovative and performent solution.\n\nFast-Finality Rollups\n\nA fast-finality rollup is a rollup secured with a Proof of Stake (PoS) protocol. In a PoS protocol, validators stake some assets (in native L2 tokens) to be incentivized to attest honestly about the status of an L2 state transition. If they are dishonest (they accept incorrect state transitions or reject correct state transitions) their stakes can be slashed. Honest validators are rewarded for their activity.\n\nFast-Finality Move Rollup\n\nA fast-finality Move Rollup can rely on a network of validators to provide fast-finality. The role of a validator is to confirm that the execution of a batch of transactions is correct. A transaction is final (irreversible) on a fast-finality Move rollup when enough validators have confirmed the correctness of a state transition. For the sake of simplicity, we assume all the validators stake the same amount and enough means more than 2/3 of the validators.\n\nA simple mechanism for implementing a fast-finality Move Rollup is:\n\nA set of validators stake some assets in a trusted L1 contract AttVerifK.\n\nOn the Move Rollup, the validators broadcast their (signed) attestations (either approving or rejecting a state transition), and at the same time collect the signed attestations from others.\n\nWhen an honest validator has collected attestations representing more than 2/3 of the total stake, they submit them to contract AttVerifK.\n\nThe contract AttVerifK verifies that the attestation signatures are valid, unique, and account for more than 2/3 of the stake. The state transition becomes final.\n\nAssuming less than 1/3 of the validators are Byzantine, there will be an honest validator who confirms the correct state transition. Due to the 2/3 majority requirement, there cannot be a malicious actor who could submit enough attestations supporting an erroneous state transition. Moreover, due to cryptographically protected signatures, they cannot forge/tamper these and craft erroneous state transitions.\n\nAttestations can be delivered in the order of seconds. Consequently, a fast-finality Move Rollup provides fast-finality and substantially improves user experience. In contrast, an optimistic rollup has a challenge window of 7 days before a transaction is final. A validity rollup (zk-proof) is faster than an optimistic rollup, but has a proof generation time in the order of 10-15 mins, and also requires expensive hardware configurations.\n\nSecurity of a Fast-Finality Move Rollup\n\nThe security level of a fast-finality Move Rollup depends on the total stake of the validators. Validators stake in the (trusted) contract AttVerifK on L1. Further, the verification that the threshold of 2/3 of the validators have confirmed a state transition is performed by contract AttVerifK. As a result the verification step inherits Ethereum security. The staking/slashing/rewarding functions are also executed on L1 with the same security level.\n\nThe overall security of the fast-finality rollup approach depends on the total stake of validators. The staking, rewarding and verification steps inherit Ethereum security.\n\n[1] Dan Guido – Podcast, Building Better Systems, 2021. What the hell are the blockchain people doing, and why isn't it a dumpster fire?\n\n[2] Dill, D., Grieskamp, W., Park, J., Qadeer, S., Xu, M., Zhong, E. (2022). Fast and Reliable Formal Verification of Smart Contracts with the Move Prover. In: Fisman, D., Rosu, G. (eds) Tools and Algorithms for the Construction and Analysis of Systems. TACAS 2022. Lecture Notes in Computer Science, vol 13243. Springer, Cham. DOI\n\nAbout Movement:\n\nMovement Labs is the innovative force behind the Movement Network, an ecosystem of Modular Move-Based Blockchains that enables developers to build secure, performant, and interoperable blockchain applications, bridging the gap between Move and EVM ecosystems. We are developing the first Move Virtual Machine L2 for Ethereum, alongside open-source tooling and protocols to facilitate the adoption of the Move programming language across blockchain ecosystems. With Movement, developers can launch high-performance Move VM rollups with ease. We aim to revolutionize blockchain interoperability and advance Move-based technologies in the Web3 space.\n\nWebsite / Twitter/X / Discord / Telegram\n\n© 2024 Movement Labs."
  },
  {
    "title": "Frax is Coming to Movement and Bringing its Whole DeFi Stack",
    "url": "https://blog.movementlabs.xyz/article/frax-movement-defi-blockc",
    "html": "Frax is Coming to Movement and Bringing its Whole DeFi Stack\nPartnerships\nAugust 15, 2024\nMovement Labs\n\nDeFi could change how we use money. But so far DeFi is failing.\n\nThe point of failure? Safety. Billions are lost to DeFi hacks each year. Many of these hacks stem from code vulnerabilities, and most would be preventable if developers coded in Move. \n\nMovement DeFi is built on an idea: in order for DeFi to reach its potential, it must be safer. A powerful DeFi ecosystem is forming on Movement, an economy of apps benefitting from Movement’s greater safety – not to mention its modularity, liquidity, interop, and speed. \n\nToday, recognizing this growth, potential, and focus on security, Frax has announced plans to natively deploy on Movement. \n\nCritically, Frax is committed to rewriting its entire Solidity codebase in Move. \n\nFrax is an OG Ethereum DeFi protocol with $600M+ in TVL. It’s a one-stop decentralized bank offering numerous assets and products, including liquidity, lending, and stablecoins. Frax effectively unites these three foundational DeFi services under one digital roof. It’s also a high-powered, battle-tested protocol that has innovated time and again while surviving severe market turbulence. With its coming launch on Movement, the whole Movement DeFi ecosystem benefits.   \n\nHow? Frax is bringing our ecosystem new assets, products, and incentives. Movement DeFi apps can use these primitives to develop more complex, efficient offerings. \n\nFrax will be introducing at least four new assets to Movement:\n\nFrax (a decentralized stablecoin pegged 1:1 to USD)\n\nsFrax (a staked version of this stablecoin)\n\nfrxETH (a liquid staking token pegged 1:1 to Eth)\n\nFXS (the staking and governance token for the Frax ecosystem)\n\nFrax will also be deploying Fraxlend, Frax CDP, and its staking contract on Movement. \n\nTo jumpstart the partnership, both Frax and Movement offer existing Frax users incentives to bridge to Movement. Frax and movement will work toward providing $10M in protocol liquidity. Frax plans to be live on Movement on Day 1 of Movement mainnet.\n\nA DeFi powerhouse deploying on Movement (and upgrading to Move and Move’s security) grows the pie massively for both parties. \n\nFor Movement, Frax expands what Movement DeFi protocols and users can do. And Movement levels up Frax in return. When an Etheruem DeFi OG like Frax deploys in Move on Movement, they trade in an old car for a Lamborghini with brakes, fine-tuned for the needs of today. \n\nMovement is the home for safe, high-performance DeFi, offering greater: \n\nSpeed (the MoveVM with Block-STM parallelization can reach 180K TPS)\n\nSecurity (the Move language circumvents 80%+ of common Solidity hacks) \n\nLiquidity (Movement unites the EVM and Move ecosystems, creating a deep liquidity hub) \n\nInteroperability (Movement is compatible with most other blockchain networks) \n\nWith the security, throughput, scaling potential, and other next-gen performance features of Movement, DeFi protocols like Frax have the platform they need to thrive. More broadly, DeFi has the home it needs to grow safely and reach its great potential. \n\nAnd that’s just the beginning. Frax and Movement have other dishes cooking.\n\nDetails to come! To learn more about Frax now, visit its website. To keep up with Frax and Movement, follow both on social media and get excited for what’s next. \n\nAbout Movement Labs\n\nCo-founders Rushi Manche and Cooper Scanlon, early builders in the Move ecosystem, founded Movement Labs in 2022 as the first integrated blockchain network, powering the fastest and most secure Layer 2 on Ethereum. Move, a smart contract language originally developed at Facebook to power the Diem (initially known as Libra) blockchain, was designed to be a secure and universal language targeting the unique qualities of smart contract programming. With its enhanced security and parallelization capabilities. Movement Labs is pioneering the Integrated Blockchain approach by bringing the MoveVM to Ethereum through its flagship L2 and connected rollups with the Move Stack, pairing Move's smart contract advantages with EVM's liquidity and user bases. This combination creates the first MEVM (Move + EVM) Zero-Knowledge Layer-2 solution on Ethereum.\n\n© 2024 Movement Labs."
  },
  {
    "title": "Security & Fast-Finality Settlement",
    "url": "https://blog.movementlabs.xyz/article/security-and-fast-finality-settlement",
    "html": "Security & Fast-Finality Settlement\nResearch\nAugust 23, 2024\nFranck Cassez\n\nRollups or Layer 2s (L2s) are scaling solutions to extend a Layer 1 (L1, e.g. Ethereum) that provides strong security guarantees. There are currently two dominant types of rollups, validity (ZK-proof) and optimistic (fraud proof) rollups. Both use an L1 for settlement, i.e. the confirmation of irreversibility (or immutability) of a transaction. Settlement time is still a problem for both types of rollups: for a ZK-rollup (ZK-RU) it is in the order of half an hour, whereas for optimistic rollups (OP-RU) it is in the order of days (typically 7). This can be a limiting factor for certain types of DeFi applications (e.g. arbitrage).\n\nAt Movement Labs, we are developing the next generation of L2s, with an execution layer powered by the high-throughput Move Virtual Machine (MoveVM) and smart contracts written in Move, a programming language offering strong security guarantees (e.g. re-entrancy is not allowed) and leveraging formal verification techniques.\n\nWhile the Movement Network is designed to support optimistic mechanisms, we strive to offer our users choices for settlement depending on their needs. This ranges from optimistic (fraud proof), to validity (zk-proof), to a new fast-finality mechanism (in the order of seconds), and to various hybrid versions of these (zk-fraud proof, fast-finality with fraud proof).\n\nIn this post, we introduce our fast-finality mechanism. We start by defining Ethereum's security and then compare the security, latency, and complexity levels of different types of settlement mechanisms, optimistic, validity, and our own fast-finality to help users decide what is best for their target applications.\n\nTL;DR\n\nThe highest level of security is provided by ZK-rollup, but the correct implementation (satisfying the ZK-trust assumptions) is complex (risks of bugs). Optimistic rollups are easier to implement, but there is a risk of invalid blocks, and they rely on a correct implementation of the dispute resolution mechanism, which is not trivial. Soft-finality, i.e. when the rollup has generated a block, is not secured in ZK-RU and OP-RU.\n\nFast-finality settlement (FFS) is simple enough to implement (so you can have high confidence in the implementation). In FFS, Soft-finality is secured by the L2 validators' stakes, which provides a minimum level of security. It is more secure than OP-RU and faster than ZK-RU.\n\nThe table below summarizes the types of settlement and their properties:\n\nType of Settlement\n\n\t\n\nComplexity of Implementation\n\n\t\n\nTime to Finality\n\n\t\n\nSoft-Finality Security Level\n\n\t\n\nFinality Security Level\n\n\n\n\nZK\n\n\t\n\nhigh\n\n\t\n\n30 minutes\n\n\t\n\nNone\n\n\t\n\nEthereum\n\n\n\n\nOP\n\n\t\n\nmedium\n\n\t\n\n7 days\n\n\t\n\nNone\n\n\t\n\nnone to Ethereum\n\n\n\n\nFF\n\n\t\n\nlow\n\n\t\n\n12 minutes\n\n\t\n\nL2 Stake\n\n\t\n\nL2-Stake to Ethereum\n\nThe Movement Network offers the choice of settlement mechanism for each chain in the network. Depending on their applications, users can decide what configuration they want to adopt to meet their needs.\n\nEthereum Security\n\nWe first define Ethereum's security and finality. You may have heard or read this several times:\n\nOur chain/protocol/rollup inherits Ethereum security.\n\nWhat does that mean? And how is security defined and quantified on Ethereum? How does it transfer to (or how is it inherited by) another component?\n\nAs we are interested in quantifying security (on Ethereum), we are going to abstract away some of the implementation details that are not relevant for this discussion.\n\nThe Abstract Model\n\nUsers submit transactions to the nodes in the (Ethereum) network. The nodes in the network build blocks. Each block 𝐵 is a triple (𝐵.𝑠𝑡, 𝐵.𝜎, 𝐵.𝑝𝑎𝑟𝑒𝑛𝑡) with:\n\nB.parent is a reference to the parent block of B.\n\nB.st is state. This is a mapping form users to their assets, and for contracts to their current states.\n\n𝐵.𝜎 is a sequence of transactions.\n\nThe genesis block 𝐺 = (𝜄, [], ⊥) is the block defined by the initial state of the system 𝜄, the empty list of transactions [], and no parent block which is denoted by ⊥.\n\nThere are reference semantics that define the state transition function. This function maps pairs (state, sequence of transactions) to states, and we write\n\nfor: from state 𝑠, executing the sequence of transactions 𝜎 leads to state 𝑠′. These semantics are implemented in the Ethereum Virtual Machine (EVM).\n\nGiven a block 𝐵, 𝑐ℎ𝑎𝑖𝑛 (𝐵) is the chain defined by recursively collecting the parent blocks of 𝐵. We assume 𝑐ℎ𝑎𝑖𝑛(𝐵) is always well-founded (finite and no cycles) and ends up in the genesis block. Given a block 𝐵 and chain(B)=Bk-1...B0 with Bk = B and B0 = G, chain(B) is valid if\n\nthe sequence of states computed since the genesis block satisfy the reference state transition semantics. (note: this definition implies that the genesis block is valid and the only chain of length 1 that is valid is the genesis block.)\n\nIf chain(B) is valid, we simply say that B is valid.\n\nProof of Stake & Finality\n\nThe consensus protocol used in Ethereum is a Proof of Stake (PoS) protocol. In Ethereum PoS, a set of nodes called validators each stake the same amount, 32ETH. The role of the validators is to determine which blocks are valid. To do so they have to attest for blocks. An honest validator attests only for valid blocks. A dishonest (Byzantine) validator can attest for non-valid blocks, many different sibling blocks, or tamper with messages (within some limitations, e.g. they cannot forge signatures). Dishonest validators can have their stake slashed if they are caught misbehaving, and honest nodes are rewarded for their good work. This mechanism incentivizes nodes to be honest.\n\nAt a (very) high-level, validators attest for blocks. When more than 2/3 of the validators have attested for a block, a block becomes finalized (in the real network, this is more complicated, as blocks at checkpoints go through different states, justified, finalized). A transaction is finalized (confirmed and irreversible) when it is included in a finalized block.\n\nUnder the assumption that less than 1/3 of the validators can be Byzantine, every finalized block is valid.\n\nIndeed, if a block 𝐵 is finalized, more than 2/3 of the validators have attested for it. In this 2/3 there must be at least one honest validator (as less than 1/3 can be Byzantine). An honest validator only attests for 𝐵 if 𝐵 is valid, so 𝐵 is valid. QED.\n\nSecurity\n\nThe Ethereum network is secure if each finalized block is valid.\n\nUnder the previous assumption that at most 1/3 of the validators can be Byzantine, the PoS protocol ensures the network is secure.\n\nBut when is this assumption realistic?\n\nTo produce an invalid finalized block, more than 2/3 of the validators must attest for it. A validator can be intentionally dishonest or unintentionally (because of a bug, or using the wrong version of the reference semantics). Let's assume that there is no unintentional dishonest validator.\n\nAssume an attacker wants to produce an invalid finalized block 𝐵, then they have to control or convince more than 2/3 of the validators to attest for it. If they only want to prevent reaching consensus (liveness), they need to control or convince 1/3 of the validators to misbehave. To control a validator, an attacker must have staked/spent 32ETH. So, assume there are 𝑉 validators, each of them staking 32ETH. The total stake (in ETH) is 𝑆 = 32 × 𝑉, and an attacker needs at least 1/3 ∗ 𝑆 (resp. 2/3) to compromise the liveness (resp. security) of the network (we assume here that there is no network partition).\n\nAs of today there are more than 1,000,000 validators operating in the Ethereum network. To control 1/3 of the validators, it would take an attacker to invest more than 1/3 × 1,000,000 × 32 × 2,800 ≈ 29,000,000 ,000 USD, close to 30 Billion, and close to 60 Billion to finalize an incorrect block.\n\nIt is very unlikely that an attacker (there is only one Elon Musk) would be able or willing to invest such a huge amount of resources. Moreover, to stake this amount would take months due to the rules in place to join and exit the validators set.\n\nSecurity is about probability. If the probability of an attack is 𝜀 we can define the security level as 1 − 𝜀. The network is secure if 𝜀 is small or negligible.\n\nThe likelihood of an attack decreases when the total stake increases, and when the total stake is very large, it becomes negligible. In that case, we can say that the \"at most 1/3 Byzantine\" assumption is realistic and the network is secure. The level of security of Ethereum (with the current total stake) is referred to as Ethereum's security.\n\nThis notion of security is different to the notion of security for smart contracts, which is the absence of bugs. The fact that Ethereum is secure does not rule out bugs that could lead to unintended results (e.g. re-entrancy attacks). In the security analysis above, we assume that if the code of a contract is executed according to the reference semantics (of the EVM), the resulting block is valid.\n\nSecurity of Validity and Optimistic Rollups\n\nA rollup is an L2 with settlement on L1 (usually Ethereum). What is that? It means that the L2 computes the next L2-block and provides some data to the L1 to verify that this block is valid.\n\nThe definitions of valid block/chain for an L2 are similar to the definitions given previously for Ethereum.\n\nValidity (ZK) Rollup\n\nIn a ZK-rollup, the L2 provides a ZK proof of validity of blocks to the L1. The proof 𝜋(𝐵) for block 𝐵 is built by a prover and is supposed to prove the statement \"Block 𝐵 is valid\". This proof is checked by a Verifier, a contract on L1.\n\nZK-Trust Assumptions. We assume that the machinery to build the proof (zk/crypto libraries) and the Prover (ZK-VM) is bug-free and:\n\nZK-A1) the Prover is correct and generates a proof 𝜋(𝐵) that is accepted by the Verifier if and only if 𝐵 is valid.\n\nZK-A2) the probability that the Verifier accepts an incorrect proof is negligible.\n\nZk-A3) the implementation of the Verifier, VerifierK, which is a contract on L1 that verifies the proof, correctly implements the Verifier algorithm.\n\nAn L2-block 𝐵 is finalized when the verifier contract has accepted the proof. This verification step is an L1 transaction and on Ethereum takes approximately 12 minutes (two epochs) to be finalized.\n\nWhat is the security level of a ZK-rollup? Under the ZK-trust assumptions above, an attacker needs to control 1/3 of the validators to prevent the VerifierK transaction to be finalised. An attacker needs to control 2/3 of the Ethereum validators to tamper with the result of the VerifierK contract and to finalize an invalid L2-block.\n\nA ZK-rollup has the same security as Ethereum and inherits Ethereum's security. Time-wise finalization takes on average 20 minutes (time to generate a proof) plus finalization on L1, 12 minutes. Overall in the order of 30 minutes.\n\nOptimistic Rollup\n\nIn an optimistic rollup, a block 𝐵 is finalized if it has not been successfully demonstrated invalid within a challenge period. For instance, assume block 𝐵 is produced by the rollup. If after the challenge period (7 days) it has not been disputed, then it becomes final (even it is not valid). If it is disputed and a third-party claims that instead of 𝐵 we should have 𝐵′, then a dispute resolution mechanism is triggered to decide between 𝐵 and 𝐵′.\n\nOP-Trust Assumptions. We assume that:\n\nOP-A1) the fraud proof service (e.g. bisection algorithm) is correct. When submitted two different blocks 𝐵 and 𝐵′ (and assuming one of them is valid), it identifies the valid block.\n\nOP-A2) the implementation of the fraud proof service is correct.\n\nAs mentioned before, the optimistic rollup set up allows invalid blocks to be finalized: an invalid block may not be disputed within the challenge window and become finalized. Under the extra assumption\n\nOP-A3) that at least one honest validator (watchtower) verifies a block within the challenge window\n\nthen an optimistic rollup is secure: it cannot finalize invalid blocks.\n\nCompared to the ZK setting this notion of security is strictly weaker than a ZK rollup, as invalid blocks can be created for free (if no dispute happens). Time-wise the challenge window is in the order of 7 days (plus 12 minutes but this is negligible), and hence finalization is 7 days.\n\nFast-Finality Settlement\n\nIn the previous set ups (ZK or Optimistic rollups), the notion of finalization is binary, yes or no, and this is either decided by an L1 transaction (verification of a proof for zk-rollups) or a timeout for optimistic rollups.\n\nWe propose here a protocol that provides fast-finality using a staking mechanism.\n\nWhen a block is produced by the L2, it is made available to L2 validators. The validators check the validity of the block and attest for it. This provides a first level of finalization (soft-finalization), the security/trust of which is determined by the number of validators that have attested for the block. The stakes of the L2 validators are managed by an L1 contract.\n\nIn a fast-finality settlement, we have a set of validators whose role is to quickly check L2-blocks. The validators stake in a contract on L1, the StakingK contract. For the sake of simplicity we assume all the validators stake the same amount, and we refer to the L2-stake for the stake locked in the StakingK contract.\n\nValidators operate L1 full nodes and L2 full nodes at the same time. When an L2-block is produced, the validators check the validity of an L2-block. An honest validator attests for an L2-block only if it is valid. They broadcast their attestations to other validators. When a validator has received attestations for a block from 2/3 of the validators, it sends the list of (signed) attestations to the StakingK contract on L1. The StakingK contract checks that:\n\nthe list of attestations is well-formed: no duplicates, the signatures correspond to validators with a non-zero stake, and\n\nthat 2/3 of the validators (super-majority) have attested for the block.\n\nWe omit the details here, but a validator sending a non well-formed list of attestations or a list that does not meet the 2/3 threshold is slashed.\n\nAn L2-block is finalized when the StakingK contract has verified the 2/3 super-majority. As this is an L1 transaction, it takes approximately 12 minutes to be finalized. The time for the L2 validators to send their attestations is in the order of seconds.\n\nFFS-Trust Assumptions. We assume that:\n\nFFS-A1) at most 1/3 of the L2 validators can be Byzantine,\n\nFFS-A2) the implementation of the StakingK contract is correct, i.e. it correctly checks the 2/3 super-majority and correctly tracks the stakes of the L2 validators.\n\nUnder the FFS-trust assumptions, if a block is finalized then it is valid.\n\nWhat is the security level of a fast-finality settlement? The actual verification of the validity of an L2-block relies on the L2 validators. The stake on the validity of the L2-block is 2/3 of the validators stake (locked in the StakingK on L1). To create an invalid L2-block an attacker needs to control 2/3 of this total L2 stake. The verification step (similar to the verification of a ZK-proof) that 2/3 of the total stake have attested for a block is an L1 transaction. To corrupt this verification step, an attacker needs to control 2/3 of the Ethereum validators' total stake.\n\nOverall to create an invalid L2-block, an attacker needs to control either 2/3 of the total L2 stake locked in the StakingK contract or 2/3 of the total stake of Ethereum's validators (to tamper with the super-majority check).\n\nThe stake in the StakingK is likely to be lower than the total stake of Ethereum's validators. However, fast-finality settlement provides a first level of security determined by the L2 stake. When paired with economically strong retstaking mechanisms it can get close to Ethereum's security.\n\n© 2024 Movement Labs."
  },
  {
    "title": "Exploring Postconfirmations to Improve L2 UX",
    "url": "https://blog.movementlabs.xyz/article/postconfirmations-L2s-rollups-blockchain-movement",
    "html": "Exploring Postconfirmations to Improve L2 UX\nResearch\nSeptember 2, 2024\nFranck Cassez\n\nIn a recent post, we introduced a fast finality mechanism. In this post, we take a deep dive into the mechanism and address these questions:\n\nHow it differs from preconfirmations\n\nHow it may complement other finality mechanisms, like ZK-proof (ZKP) or Fraud Proof (FP)\n\nImprovements and optimizations\n\nWhat Is the Problem We Want to Address?\n\nLayer 2s (L2) and rollups have to publish transaction data to a data availability (DA) layer or to Ethereum mainnet (Layer 1, L1). Validity (ZKP) and optimistic (FP) rollups can finalize (confirm) transactions within approximately 30 minutes (ZKP) resp. ~1 week (FP). Until a transaction is finalized, there is no assurance about its validity and result (success or failure). This can be a limiting factor for certain types of DeFi applications.\n\nSo the question is:\n\nCan we design a mechanism that quickly provides some guarantees about the result of a transaction on an L2?\n\nThe answer is yes—with postconfirmation. This idea is summarized in Fig. 1.\n\nFigure 1: Security levels and time to finality. The time to finality does not include L1 (Ethereum) average finalization time which is ~13 minutes. For ZK-proof, it is the time to generate the proof. And for fraud proof, it is in the order of 1 week, so 13 minutes does not make any difference.\n\nZK-proofs provide the maximum level of security and inherit Ethereum security (for a precise meaning of inherits, we refer the reader to this recent post); finality is ~30 minutes. Fraud proofs provide a level of security ranging from none (if the challenge period ends and no validator checks the result) to Ethereum's security; Finality is ~7 days for FP.\n\nAn intermediate level of security, L2 stake security, can be provided by the L2 via postconfirmation (we explain what they are in the sequel).\n\nPostconfirmations are fast (~1 second) because they are delivered right after the execution of a block of transactions when a new block is created.\n\nOverall, the user can now have some guarantees, quickly, about the result of their transactions, and can decide whether this is good enough to assume confirmation or to wait for L1 finality (with a ZKP or a FP) to get Ethereum's level of security.\n\nSome centralized exchanges provide early confirmations of transactions based on the number of blocks that follow the block a transaction is in. However, there is no guarantee attached to this early confirmation unless finalization is provided by a longest-chain mechanism.\n\nPreconfirmations vs. Postconfirmations\n\nThe mechanism we propose is to provide postconfirmations for L2 transactions. This is depicted in Fig. 2. This mechanism is different than preconfirmations as in based sequencing. It provides a guarantee that the new block is correct, not only that a transaction will be included (or executed). It is not a replacement for the complex execution tickets mechanism, as it does not provide a way to influence the creation of a block, but rather to report on the correct execution of the transactions in a block.\n\nFigure 2: Confirmation stages of a transaction. Preconfirmation is a promise (by the sequencer) that a transaction will be included in the next block(s). In contrast, postconfirmation aims to offer some guarantees, backed by the L2 stake, that the new state (after the executor has processed a transaction) is correct.\n\nHow Does Postconfirmation Work?\n\nA network of validators (Fig. 3) is in charge of verifying new blocks. Each validator has to stake some assets in an L1 StakingK contract. We assume each validator stakes the same amount.\n\nWe assume that at most 1/3 of the validators can be dishonest (Byzantine). An honest validator attests (positively) for a block only if it is correct.\n\nWe refer the reader to this post for a precise definition of correctness.\n\nFigure 3: A network of validators verify a new block. They submit their signed attestations confirming/rejecting a new block to a staking contract on L1.\n\nA simple design (we refine it in the sequel) is that each validator sends their attestations ✅ or ❌ to the StakingK contract. Once the contract has received a 2/3 (super-majority) of positive ✅ attestations for a new block, the new block is postconfirmed.\n\nWhat Confidence Can We Have in Postconfirmation?\n\nValidators send their attestations to the StakingK and they cannot change or withdraw them and are committed to them. If later on (when verifying a block with a ZK proof or fraud proof) they are found to be incorrect (intentionally or non intentionally), they are slashed. As a result:\n\nWhen they attest, they have an incentive to do so honestly, or otherwise they may lose their stakes.\n\nThey cannot undo their votes, and when 2/3 (super-majority) have committed their positive votes, we can have high confidence that a new block is correct. This holds even if the execution of the transaction (StakingK) that checks the super-majority has not been finalized yet on L1.\n\nIf the total stake in the StakingK is large, it is hard for an attacker to control more than 1/3 of validators to prevent obtaining a super-majority, and even harder to control 2/3 to validate an incorrect block. The L2 stake security level (Fig. 1) can get close to Ethereum's security level if enough validators (and stakes) participate in the network.\n\nThe StakingK contract manages the stakes (staking, rewarding, and slashing) and is assumed to be correct (free of bugs). It offers a function to receive the signed attestations and to verify the signatures along with the 2/3 super-majority threshold. It is executed on L1 and its execution inherits Ethereum's security.\n\nIn this design, there is no requirement for validators to re-compute the new block to verify it is correct. They only have to ensure that when they attest positively, this new block is correct (so they could attest without performing any check). Moreover, the previous simple design may be quite expensive if each validator issues an L1 transaction to cast their attestations. We address these two limitations in the next sections.\n\nAggregating Attestations\n\nTo make the attestation process more efficient, we can require the validators to run an L1 light client. They have access to the state of StakingK and can determine themselves how many validators are active.\n\nAn active validator is a validator that has not been slashed of their stakes. We assume here that the slashing mechanism slashes the entire stake of a validator if they are slahed.\n\nThe validators can broadcast their votes for a new block to the entire validators' network. The validators can record and aggregate signed attestations. When one of the validators has determined that the 2/3 super-majority is reached, they can send the aggregated (signed) attestations to the StakingK contract. This reduces the number of L1 transactions needed to record the attestations.\n\nWe should also note that:\n\nThe validators record both positive ✅ and negative ❌ attestations and send both types of attestations to the StakingK. Once a 2/3 super-majority is reached, the StakingK contract can slash the validators that attested negatively, as they are dishonest (under the assumption that at most 1/3 of validators can be Byzantine).\n\nAs validators rely on a recent state of StakingK contract (to compute what the 2/3 majority threshold is), we have to prevent validators from withdrawing their stakes too quickly. This is to ensure that a dishonest validator cannot wrongly/dishonestly attest and then withdraw their stakes before being slashed. We can lock the stakes for a pre-defined amount of time (a few epochs).\n\nIt does not matter whether an honest or dishonest validator posts the aggregated signatures. Assuming signatures cannot be tampered with, a dishonest validator can only withhold some signatures or not posting anything to the L1, but cannot forge an invalid set of attestations.\n\nCommitment Hiding\n\nAs mentioned, validators could attest without checking a new block. For instance, if a validator has collected more than 1/3 of positive attestations, they could blindly attest positively too (assuming at most 1/3 of validators can be Byzantine this is low risk).\n\nTo incentivize validators to do some actual verification, we can ask them to provide a proof that they have re-computed the new block (if no ZKP exists yet, this is the only way to check the correctness of a block).\n\nFigure 4: The new block/state is not revealed until 2/3 of the validators have attested for it. Validators can submit (ZK) proofs along with their attestations.\n\nIn this set up (Fig. 4), we have to keep the new block/state hidden until a 2/3 majority has attested for it.\n\nTo do so, we can send the sequence of transactions 𝑡1,⋯,𝑡k, the source state 𝑠0 and a hash, #𝑠𝑘, of the new block/state 𝑠𝑘 without revealing the new state 𝑠𝑘 for now. Validators can broadcast a positive attestation together with a ZKP that they know a state 𝑠′ the hash of which is the same as #𝑠𝑘 (this is easier to compute than a ZKP of the entire execution of transactions). As a hash function cannot be reversed and is collision-free, if they know such a state 𝑠′ this implies that:\n\n𝑠𝑘 is the same as 𝑠′\n\nThey must have re-computed (with high probability) the new state 𝑠′ (it is very unlikely they guessed it)\n\nThis provides even more confidence that a new block/state is correct, as it enforces its verification. At the same time, it enables us to weaken the trust assumptions in the sense that we may not need to assume that honest validators re-compute the new state, they have to prove it.\n\nWe can still allow validators to submit attestations without a proof, but they may get a smaller reward compared to those who do more (verifiable) work.\n\n© 2024 Movement Labs."
  },
  {
    "title": "All you need is DAG* (for Sequencing)",
    "url": "https://blog.movementlabs.xyz/article/dag-sequencing-decentralized-sequencer-blockchain",
    "html": "All you need is DAG* (for Sequencing)\nResearch\nSeptember 17, 2024\nAndreas Penzkofer\n\nAt Movement Labs we are passionate about decentralization and the promises of distributed blockchain technology.\n\nThe centralized sequencer is a central point of failure and imposes great trust assumptions. Time to replace it.\n\nA common critique of Ethereum rollups is centralization of architecture and in particular the sequencer, which determines transaction order. Generally, rollups can be decentralized in many ways, such as using randomness as in fair sequencing. However, we seek to achieve additional properties, such as interoperability, so we have specific requirements for our solution. These can be met by a Byzantine Fault Tolerant (BFT) consensus protocol.\n\nBFT protocols are designed to ensure consensus within a distributed system, even in the presence of Byzantine (malicious) entities. They allow a set of nodes to agree on a single sequence of actions, ensuring some properties, such as consistency, integrity, and reliability. Although chain-based BFT protocols have greatly improved in recent years, there is the question of whether they can meet high-performance standards for throughput and latency, which are required to match Movement's lightning fast execution engine.\n\nThis post focuses on the application of DAG-based consensus protocols for the purpose of agreeing on the transaction ordering in a Movement decentralized sequencer. We will explore recent innovations and how these have brought about high-performance, low-latency consensus protocols, in particular Shoal++** and Mysticeti.\n\nThe ability of DAG-BFT protocols to process a high througput of transactions with minimal theoretical delays sets unrivaled benchmarks for blockchain consensus mechanisms and makes them great candidates for the consensus protocol under the hood of the decentralized sequencer of Movement.\n\nChain-based BFT Protocols\n\nFirst, let's consider chain-based BFT protocols. These are designed around a central node, known as the leader, which is responsible for proposing blocks containing transactions to the network. These protocols typically involve a series of communication phases where the leader's proposals are validated and voted on by other nodes (replicas). To ensure fault tolerance and maintain network integrity, they include mechanisms for a view change, allowing the network to dynamically elect a new leader if the current leader fails or behaves maliciously. The consensus algorithm in these protocols aims to be efficient, with communication complexity growing linearly with the number of nodes, in the best case. It may incorporate optimizations like pipelining, threshold signatures, or optimistic responsiveness to enhance performance and reduce communication complexity. Popular examples of chain-based BFT protocols include Tendermint, PBFT and Hotstuff.\n\nDAG-based BFT consensus protocols\n\nDirected Acyclic Graph (DAG)-based BFT consensus protocols, or short DAG BFTs, are a more recent development rapidly gaining in popularity. These achieve unparalleled throughput with similar or better latency guarantees compared to state-of-the art linear BFT protocols, if rounds are permitted to progress without certification. In contrast to a chain-based BFT protocol, blocks are proposed by multiple nodes concurrently. In this type of protocol, each of the proposed blocks references multiple previous blocks. This results in a DAG data structure, in which blocks and references are represented by vertices and edges, respectively. The DAG then presents a record of the communication pattern in the network, as it contains additional information about the view of each validator.\n\nVertices in a DAG are called nodes. Also, block proposers in a network are called nodes. To avoid ambiguity, we refer to a node in the network as a validator or proposer, and to nodes in a DAG as block or vertex.\n\nSeveral DAG BFT protocols have been introduced in the last decade. For instance, Tangle (2015+2022), Hashgraph (2018), Aleph (2019), and Narwhal+Tusk (2021). Aleph in particular proposed the first randomized round-based DAG protocol that enables optimistic responsiveness. Additional breakthroughs in recent years have resulted in modern high-performance DAG BFTs. Examples – with their affiliated blockchain projects in parenthesis – are Mysticeti (Sui), Shoal++ (Aptos), Sailfish (Supra) and BBCA (Chainlink).\n\nOne key realization: the separation of data dissemination and consensus can unlock significant performance gains. In this model, data dissemination is typically implemented in the form of a reliable broadcast protocol, while the consensus protocol is operated using zero-communication overhead by only locally interpreting the DAG. All Narwhal-based protocols take this approach. In this blog, we focus on consensus rather than broadcast protocol. (For more on the broadcast protocol, see this blog on Quorum Store, which is an implementation of Narwhal.)\n\nA Note on Communication Complexity\n\nIn the quest to achieve high performant blockchains, much attention was given to reducing the communication complexity. Various approaches including signature aggregation and optimization of network patterns have led to the desired low complexity, yet throughput falls short.\n\nA significant advancement originated from the recognition that a major bottleneck lies in data dissemination, which can be greatly enhanced through parallelization of block propositions. Narwhal and Tusk innovatively address the challenge by separating data dissemination from the core consensus process. In this model, all validators collaborate to broadcast data concurrently, while the consensus mechanism is a deterministic ordering protocol over metadata of transactional data, such as the hashes of blocks. And while DAG BFTs can incur a significant overhead in communication complexity, this would only be over the metadata. This separation allows for improved efficiency, leading to impressive throughput in recent DAG BFTs (see figure below). Lastly, the complexity can be reduced by at least a linear factor through amortization (see Cordial Miners and DAG Rider).\n\nThroughput-Latency graph comparing Mysticeti with state-of-the-art consensus protocols [Ref].\n\nRecent innovations in DAG-BFTs\n\nMany of the recent improvements in the DAG-BFT protocols aim to improve latency by reducing the number of required message delays. In our blog, we describe several of these breakthroughs that enable the performant DAG-BFTs of today. The explored improvements are\n\nDAGs with and without certification of blocks\n\nLeader reputation and removal of timeouts for better responsiveness\n\nPipelining of the the protocol\n\nMulti-Leader\n\nMulti-DAG\n\nThe following figure provides an overview of a subset of the DAG-BFT protocols and improvements. The concepts discussed in this blog are marked in green and red.\n\nHistory of the evolution of Shoal++ and Mysticeti. These two protocols share many properties (red), but also add several distinct approaches (green).\n\nCertified and Uncertified DAGs\n\nIn a consensus algorithm, the time it takes to achieve progress is measured in message delays. Message delays are the time it takes for a message to travel from a sender to a receiver across the network. Consensus protocols are also measured in number of rounds it takes to confirm a block, although this metric is less meaningful.\n\nMany initial approaches for DAG BFTs require the certification of a block. This entails the propagation of a proposed block to all validators in the network, the signed response of at least 2𝑓+1 (>⅔) of validators, and the issuance of a certification which contains the aggregated certificate.\n\nExamples of this type of protocol are Narwhal&Tusk and Aleph. This process imposes 3 message delays to complete a round, where a message delay is a network interaction step. This is in contrast to an uncertified DAG, where blocks are broadcast and this concludes the round. For comparison, it takes 2 message delays to complete a round in a linear BFT, where the leader collects responses, aggregates them, and then broadcasts the result.\n\nThe certification prevents equivocation since at most one certified block exists for a given validator. It also provides guarantees on the data availability, as validators would only sign in favor of a block once the transactions referenced within the block are received. Consequently, a certified block can be added to the DAG even if not all transactions in the block are received locally. Whereas in an uncertified DAG, missing transactions must be fetched first.\n\nTo derive a final sequence on the transactions in the DAG, a special role is given to the block issued by a leader, called anchor. To finalize (or commit to) an anchor, 𝑓+1 (>⅓) of referencing certified blocks are required. While Shoal++ in principle is a certified DAG protocol, the above step can be accelerated, as it is sufficient if 2𝑓+1(>⅔) uncertified blocks reference the anchor. All blocks referenced by the committed anchor and including the anchor itself are ordered by some deterministic rule. Blocks referenced by a committed anchor are final.\n\nBullshark’s direct commit rule requires f+1 certified vote vertices to commit an anchor, while Shoal++ can also commit with 2f+1 (uncertified) vertices [Ref].\n\nIn an uncertified DAG, as is the case with Mysticeti, blocks are not certified directly. Hence, an anchor strictly requires two consecutive rounds of 2𝑓+1 (>⅔) of references to be committed. (In contrast, in a certified DAG blocks are eventually accompanied by their certificate, and thus require one less round of references.) Since an uncertified DAG permits equivocation on blocks, Mysticeti relies on the concept of patterns to agree on whether to commit or skip a block. If a block obtains support from 2𝑓+1 (>⅔) validators in the subsequent round, it follows the certificate pattern. In contrast, if the block has no support from 2𝑓+1 (>⅔) validators from the next round, it follows the skip pattern and can be safely ignored. Otherwise, an indirect decision in consecutive rounds has to be awaited. A block that obtains 2𝑓+1 (>⅔) support and becomes certified is considered available, and no other block from the verifier can exist at that height. While this approach offers the least message delays (only one message delay per round), it may open the protocol to data fetching on the critical path if package loss occurs, which could increase the number of message delays on average.\n\nSkip pattern (left) and Certificate pattern (right) [Ref].\n\nResponsiveness, timeouts, and leader reputation\n\nSimilarly to Hotstuff, DAG-based protocols can operate responsively, i.e. they progress at actual network latency. More specifically, a validator can immediately issue a block for the next round once it has accumulated 2𝑓+1 (>⅔) of referenceable blocks of the current round. During good network conditions – when messages are delivered quickly – such a protocol can reach consensus rapidly. While, during bad network conditions the protocol can become slow but remains safe. Such behavior is called optimistic responsive. Shoal improves on this by partially eliminating timeouts, achieving prevalent responsiveness.\n\nHowever, we know that due to FLP deterministic consensus protocols cannot guarantee liveness in asynchrony without timeouts. To ensure that a leader has a chance to contribute–a property falling under the category of fairness–validators should wait up to some timeout period to receive the round leader block. This would increase chances to reference the anchor and support progress. For rounds where the leader is slow, protocol latency is increased.\n\nShoal takes a different approach, which challenges the doctrine of fairness toward slow leaders. Instead, the protocol does not await the leader block. The DAG is utilized to extract a function on the performance of the validators, called leader reputation. This function is applied to determine the sequence of leaders and penalize slow validators by removing them from the leader set. In practice, a fallback to timeouts after a configurable number of skipped anchors is still required to prevent certain attacks.\n\nPipelines\n\nIn traditional BFT protocols, the finalization of blocks occurs in waves, where each wave consists of multiple rounds. This also holds true for DAG-BFTs, where the number of rounds depends on the protocol. For Mysticeti it is 3 (propose, vote, certify), while for Shoal it is 2 (propose+certify, commit). Since the period of these waves can be quite long, it burdens transactions with large finality times, on average.\n\nBy serializing multiple instances of the consensus protocol–a process called pipelining–the average number of rounds to finality can be reduced. The total order of anchors is established by letting instances add anchors in round-robin fashion.\n\nPipelined DAG. The vertices corresponding to the leaders are marked with an anchor. If only one instance of the protocol is active, not every round would have an anchor. By adding protocol instances and rotating the instances in round robin-fashion, anchors are provided every round [Ref].\n\nMulti-Leader\n\nPipelining achieves a latency improvement for the anchor itself and blocks referenced by the anchor. However, there are still many blocks proposed in the same round as the anchor, but which would not be finalized at the same time. By making every proposer a leader and ordering the anchors according to a predetermined sequence, this drawback can be removed. But since all validators follow the same deterministic order, an anchor that cannot be directly committed increases the latency for all subsequent anchors. Consequently, fallback mechanisms, such as round timeouts, come into play, which could reduce the benefits of responsiveness. Leader reputation, discussed in a previous section, can remove slow or crashed validators to ensure low latency [Ref].\n\nPipelined Multi-Leader DAG. Each color presents an anchoring round for one of the pipelined protocol instances. For a given round the leaders are ordered by letter [Ref].\n\nMulti-DAG\n\nSimilar to pipelining, where several instances of the protocol are applied in series on the same DAG, one could also apply several instances of DAGs and serialise these. The goal is to improve granularity of the block frequency and reduce latency between transaction arrival and transaction inclusion in a block. However, since DAGs would write to the final sequence in round-robin fashion, these DAGs would interdepend with their latency as progress would depend on the slowest finalization.\n\nEvaluation and Summary\n\nThe following provides an overview of which of the above presented techniques are employed by Shoal++, Mysticeti, and Hotstuff. Since Hotstuff follows a chain-based approach, some of these concepts are not applicable to it (n/a).\n\nProperty\n\n\t\n\nMysticeti\n\n\t\n\nShoal++\n\n\t\n\nHotstuff\n\n\n\n\nResponsiveness\n\n\t\n\n❌\n\n\t\n\nPrevalent\n\n\t\n\nOptimistic\n\n\n\n\nUncertified DAG\n\n\t\n\n✅\n\n\t\n\n❌\n\n\t\n\nn/a\n\n\n\n\nLeader reputation\n\n\t\n\n✅\n\n\t\n\n✅\n\n\t\n\n❌\n\n\n\n\nPipelining\n\n\t\n\n✅\n\n\t\n\n✅\n\n\t\n\n✅\n\n\n\n\nMulti-Leader\n\n\t\n\n✅\n\n\t\n\n✅\n\n\t\n\nn/a\n\n\n\n\nMulti-DAG\n\n\t\n\n❌\n\n\t\n\n✅\n\n\t\n\nn/a\n\nNext, we evaluate the number of message delays it takes to finalize a message that is sent by a user. (Message delays are introduced in the section on \"Certified and Uncertified DAGs\".) We also consider queuing, which is the time between arrival of a transaction and the inclusion in a block. The expected delay due to queuing is the mean between max and min of possible queuing time. Mysticeti is advantageous in that respect, as its rounds progress with only 1 message delay, whereas with Shoal++ a round consumes 3 message delays due to certification. However, Shoal++ also introduces the concept of Multi-DAGs which can reduce queuing time dramatically. We note that since rounds in Hotstuff (and Hotstuff2) progress with 2 message delays, queuing also effectively adds 1 message delay in this protocol. We compare with the optimal two-phase BFT Hotstuff2.\n\nPerformance\n\n\t\n\nMysticeti\n\n\t\n\nShoal++\n\n\t\n\nHotstuff [*]\n\n\n\n\nCommit delay\n\n\t\n\n3\n\n\t\n\n4\n\n\t\n\n5\n\n\n\n\nQueuing\n\n\t\n\n0.5\n\n\t\n\n0.5\n\n\t\n\n1\n\n\n\n\nTotal\n\n\t\n\n3.5\n\n\t\n\n4.5\n\n\t\n\n6\n\nWe reference a sample of performance results from Mysticeti and Shoal++. Overall the results are impressive, significantly outperforming traditional protocols.\n\nWe also compare the results to Hotstuff.\n\nPerformance\n\n\t\n\nMysticeti\n\n\t\n\nShoal++\n\n\t\n\nHotstuff [*]\n\n\n\n\nThroughput\n\n\t\n\n>150k tps\n\n\t\n\n>150k\n\n\t\n\n>25k\n\n\n\n\nLatency at ~50% peak tps\n\n\t\n\n1 sec\n\n\t\n\n1 sec\n\n\t\n\n2 sec\n\n\n\n\nLowest achieved latency\n\n\t\n\n~0.5sec (*)\n\n\t\n\n~0.8 sec\n\n\t\n\n~2 sec\n\nThe experimental setup consists of 100 replicas spread across multiple regions around the world to mimic a decentralized network [Ref]. Apart from (*), where the result is extracted from an experiment with only 50 replicas [Ref].\n\nConclusion\n\nDAG-based BFT consensus protocols represent a significant advancement in decentralized consensus protocols. They leverage innovations such as data dissemination separation, uncertified blocks, leader reputation mechanisms, and pipelining to enhance performance.\n\nMysticeti and Shoal++, two specimen of DAG BFTs, demonstrate unparalleled throughput and latency improvements, even compared to state-of-the art chain-based BFT protocols like Hotstuff. Their ability to process transactions with minimal theoretical delays sets unrivaled benchmarks for blockchain consensus mechanisms and makes them great candidates for the consensus protocol under the hood of the decentralized sequencer of Movement.\n\nFOOTNOTES\n\n*DAG-Rider, an asynchronous Byzantine Atomic Broadcast protocol, was introduced in 2021 with this title. It is one of the many novel DAG-based solutions in the space.\n\n**It has also been announced that [Raptr] will be the successor of Shoal++. However, as of this writing, no paper, results, or code are yet available.\n\n© 2024 Movement Labs."
  },
  {
    "title": "How to Get Involved with Movement's Testnet",
    "url": "https://blog.movementlabs.xyz/article/movement-testnet-movedrop-parthenon-how-to-use",
    "html": "How to Get Involved with Movement's Testnet\nAnnouncements, Testnet\nJuly 30, 2024\nMovement Labs\n\nMovement’s public testnet is NOW LIVE. \n\nWith the launch of our public testnet, developers and users have a live environment to use Movement’s next-gen L2. Movement offers far greater security through Move and uses the parallelized MoveVM, the first Move virtual machine L2 for Ethereum. Movement is integrated, allowing devs to choose the best modular pieces. Movement also uses Celestia for data availability, providing a high-throughput solution for posting transaction data off-chain while still settling to Ethereum.\n\nSix of our launch partners have their apps deployed. Many more are coming. Yes, you can use Movement today. Here’s how.\n\nThe MoveDrop\n\nThe MoveDrop is an incentivized testnet program. It provides a way for the community to come together to build something: Parthenon (AKA Movement mainnet). \n\nAnybody can join. Participants receive trophies, medals, resources, and ethos for actions. These are the foundation of MoveDrop participation and recognition. \n\nThe MoveDrop has four primary pieces. \n\nMoveDrop homepage\n\n1. The Battle of Olympus (for Devs)\n\nDevelopers can build on the Movement testnet through our Battle of Olympus. This hackathon is for elite blockchain devs (and dev teams). More than 750 teams are already registered! \n\nTeams are ranked on a master leaderboard, moving up or down based on progress. Devs can build in DeFi, gaming and entertainment, social and community tools, infrastructure and dev tools, and NFTs.\n\nYou’re still early! The battle has only just begun and it ends in September\n\nOlympus homepage\n\nOlympus registration\n\n2. Building the Parthenon (for Everyone)\n\nBuilding the Parthenon is an incentivized testnet program open to all. No matter your speciality, you can join this community-driven journey to mainnet. It starts TODAY, with public testnet. \n\nHere’s how you can start participating ASAP:\n\nComplete weekly guild quest lines on Movement’s Galxe\n\nEngage with partner ecosystem projects to support Movement\n\nJoin a Movement guild (best option)\n\nMovement guilds provide specific tracks for you to follow based on your skills and interests. You’ll help build the Parthenon with fellow Movers. Our guilds:\n\nPathfinders: network explorers\n\nCreators: creators + storytellers\n\nExplorers: test features + provide feedback\n\nScholars: researchers + educators\n\nSpartans: on-chain testooooors\n\nBuilding the Parthenon\n\nJoin a Movement Guild\n\n3. Gmove Campaign \n\nYou can win trophies for saying “gmove” on X. Yes, really! \n\n4. Centurions \n\nWe’ll also be launching a program for committed participants. More TBA.\n\nDeveloper Docs and Resources\n\nMovement Documentation\n\nGetting Started Building on Movement\n\nMovement Learning Resources\n\nTimeline\n\nMovement Public Testnet Live: today\n\nBattle of Olympus: now through September 17\n\nRoad to Parthenon: now through mainnet\n\nWen Mainnet: soon\n\nGo Forth and Build\n\nWhat are you waiting for? Whether you're a dev, creator, or community enthusiast, there's a place for you in the Movement. Every quest you complete boosts your standing.\n\nWe're pumped to build with you!\n\nAbout Movement:\n\nMovement Labs is the innovative force behind the Movement Network, an ecosystem of Modular Move-Based Blockchains that enables developers to build secure, performant, and interoperable blockchain applications, bridging the gap between Move and EVM ecosystems. We are developing the first Move Virtual Machine L2 for Ethereum, alongside open-source tooling and protocols to facilitate the adoption of the Move programming language across blockchain ecosystems. With Movement, developers can launch high-performance Move VM rollups with ease. We aim to revolutionize blockchain interoperability and advance Move-based technologies in the Web3 space.\n\nWebsite / Twitter/X / Discord / Telegram \n\n© 2024 Movement Labs."
  },
  {
    "title": "Movement Labs Blog",
    "url": "https://blog.movementlabs.xyz/",
    "html": "Announcements, Testnet\nJuly 30, 2024\nHow to Get Involved with Movement's Testnet\n\nThe Movement public testnet is now live. Here's how to participate.\n\nRead More\nCATEGORIES\nSearch by Keyword\nResearch\nSeptember 17, 2024\nAll you need is DAG* (for Sequencing)\nResearch\nSeptember 2, 2024\nExploring Postconfirmations to Improve L2 UX\nResearch\nAugust 23, 2024\nSecurity & Fast-Finality Settlement\nPartnerships\nAugust 15, 2024\nFrax is Coming to Movement and Bringing its Whole DeFi Stack\nAnnouncements, Testnet\nJuly 30, 2024\nHow to Get Involved with Movement's Testnet\nResearch, Tech Deep Dives\nJuly 29, 2024\nMovement Labs Research Explains: What Is Movement?\nAnnouncements\nJune 13, 2024\nMovement’s Battle of Olympus Calls for Heroes!\nTutorials\nJune 6, 2024\nTutorial: Building an EigenLayer AVS that integrates with Movement network\nMay 26, 2024\nCommunity vs Insiders: Can They Both Win?\n1\n2\nNEXT\n© 2024 Movement Labs."
  }
]